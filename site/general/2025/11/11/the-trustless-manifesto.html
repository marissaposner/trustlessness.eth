

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<base href="../../../../">

<link rel="stylesheet" type="text/css" href="../../../../css/common-vendor.b8ecfc406ac0b5f77a26.css">
<link rel="stylesheet" type="text/css" href="../../../../css/font-vendor.b86e2bf451b246b1a88e.css">
<link rel="stylesheet" type="text/css" href="../../../../css/fretboard.f32f2a8d5293869f0195.css">
<link rel="stylesheet" type="text/css" href="../../../../css/pretty.0ae3265014f89d9850bf.css">
<link rel="stylesheet" type="text/css" href="../../../../css/pretty-vendor.83ac49e057c3eac4fce3.css">
<link rel="stylesheet" type="text/css" href="../../../../css/misc.css">
<link rel="stylesheet" type="text/css" href="../../../../css/main.css">

<script type="text/javascript" id="MathJax-script" async
  src="../../../../scripts/mathjax.js">
</script>

<style>
@font-face {
    font-family: MJXc-TeX-math-Iw;
    src: url("https://assets.hackmd.io/build/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff")
}
@font-face {
    font-family: MJXZERO;
    src: url("https://assets.hackmd.io/build/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff")
}
@font-face {
    font-family: MJXTEX;
    src: url("https://assets.hackmd.io/build/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff")
}

.math { font-family: MJXc-TeX-math-Iw }
@media (prefers-color-scheme: dark) {
    body {
        background-color: #1c1c1c;
        color: white;
    }
    .markdown-body table tr {
        background-color: #1c1c1c;
    }
    .markdown-body table tr:nth-child(2n) {
        background-color: black;
    }
}
html.light body {
    background-color: #fff;
    color: #333;
}
</style>

<div id="doc" class="container-fluid markdown-body comment-enabled" data-hard-breaks="true">


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="The Trustless Manifesto" />
<meta name="twitter:image" content="../../../../images/trustlessness-icon.png" />

<div class="color-toggle" id="color-mode-switch">
  <svg xmlns="http://www.w3.org/2000/svg" class="toggle-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
  </svg>
  <input type="checkbox" id="switch" />
  <label for="switch">Dark Mode Toggle</label>
  <svg xmlns="http://www.w3.org/2000/svg" class="toggle-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
  </svg>
</div>

<script>
  window.addEventListener('DOMContentLoaded', () => {
    const root = document.documentElement;
    const toggle = document.querySelector('#color-mode-switch input[type="checkbox"]');
    if (!toggle) return;

    const applyScheme = (mode) => {
      if (mode === 'dark') {
        root.classList.add('dark');
        root.classList.remove('light');
      } else {
        root.classList.add('light');
        root.classList.remove('dark');
      }
      localStorage.setItem('colorScheme', mode);
    };

    const stored = localStorage.getItem('colorScheme');
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const initialMode = stored || (prefersDark ? 'dark' : 'light');
    applyScheme(initialMode);
    toggle.checked = initialMode === 'dark';

    toggle.addEventListener('change', () => {
      applyScheme(toggle.checked ? 'dark' : 'light');
    });
  });
</script>

<h1 id="the-trustless-manifesto">The Trustless Manifesto</h1>
<p><strong>Authors: Yoav Weiss, Vitalik Buterin, Marissa
Posner</strong></p>
<p><em>Special thanks to pcaversaccio, Tim Clancy, and Dror Tirosh for
feedback and review.</em></p>
<hr />
<h2 id="i.-why-trustlessness-matters">I. Why trustlessness matters</h2>
<p>Every system begins with good intentions.<br />
A hosted node here, a whitelisted relayer there.<br />
Each is harmless on its own — and together they become habit.</p>
<p>Gateways become platforms.<br />
Platforms become landlords.<br />
Landlords decide who may enter and what they may do.</p>
<p>The only defense is <em>trustless design</em>: systems whose
correctness and fairness depend only on math and consensus, never on the
goodwill of intermediaries.</p>
<p>Trustlessness is not a feature to add after the fact.<br />
It is <strong>the</strong> thing itself.<br />
Without it, everything else — efficiency, UX, scalability — is
decoration on a fragile core.</p>
<p>Trustlessness is how credible neutrality is achieved.<br />
Without it, the system becomes one that depends on intermediaries.</p>
<hr />
<h2 id="ii.-why-we-build-on-ethereum">II. Why we build on Ethereum</h2>
<p>We build on Ethereum because we choose verification over blind
trust.<br />
We write code so that power cannot hide behind policy.<br />
We design protocols so that freedom does not depend on permission.</p>
<p>Ethereum was not created to make finance efficient or apps
convenient.<br />
It was created to set people free — to empower anyone, anywhere to
coordinate without permission and without trusting anyone they cannot
hold accountable.</p>
<p>Ethereum is the path to trustlessness.<br />
That promise must not be lost as we scale.</p>
<hr />
<h2 id="iii.-what-trustlessness-means">III. What trustlessness
means</h2>
<p>A system is trustless when any honest participant can join, verify,
and act <strong>without permission and without fear</strong>.</p>
<p>This requires:</p>
<ol type="1">
<li><strong>Self-sovereignty</strong> — each user authorizes their own
actions; no one acts on their behalf.<br />
</li>
<li><strong>Verifiability</strong> — anyone can confirm what happened
from public data.<br />
</li>
<li><strong>Censorship resistance</strong> — any valid action can be
included, within a reasonable timeframe and without undue cost.<br />
</li>
<li><strong>Walkaway test</strong> — if one operator disappears or
misbehaves, another can step in without approval.<br />
</li>
<li><strong>Accessibility</strong> — participation must be within reach
of ordinary users, not only experts with servers and capital.<br />
</li>
<li><strong>Transparency of incentives</strong> — participants are
governed by protocol rules, not private contracts or opaque APIs.</li>
</ol>
<p>Remove any of these, and the system drifts from protocol to platform
— from neutral ground to private property.</p>
<hr />
<h2 id="iv.-what-trustlessness-demands">IV. What trustlessness
demands</h2>
<p>Trustlessness is expensive.<br />
It requires redundancy, openness, and complexity.<br />
It requires mempools that anyone can use, even if that invites
spam.<br />
It requires clients that anyone can run, even if few will.<br />
It requires governance that moves slowly, because no one can override
consensus.</p>
<p>Every shortcut that assumes trust eventually costs freedom.<br />
Trustlessness depends on free open source software — not only code that
can be read, but code that can be freely run, verified, and
improved.</p>
<p>A trustless design must therefore obey three laws:</p>
<ol type="1">
<li><p><strong>No critical secrets.</strong><br />
No step of a protocol should depend on private information held by a
single actor — except the user themselves.</p></li>
<li><p><strong>No indispensable intermediaries.</strong><br />
Anyone who forwards, executes, or attests must be replaceable by any
other participant following the same rules.<br />
"Anyone can run one" is not enough — participation must be
<em>practically</em> open, not reserved for those with servers, funding,
and DevOps skills.<br />
A system that depends on intermediaries most users cannot realistically
replace is not trustless; it merely concentrates trust in the hands of a
smaller class of operators.</p></li>
<li><p><strong>No unverifiable outcomes.</strong><br />
Every effect on state must be reproducible and checkable from public
data.</p></li>
</ol>
<p>These laws are harsh. They limit what we can build easily.<br />
But they are the only guarantee that what we build belongs to
<strong>everyone</strong>.</p>
<hr />
<h2 id="v.-the-drift-toward-dependence-on-trust">V. The drift toward
dependence on trust</h2>
<p>The drift is not theoretical. It is already here.<br />
Hosted RPCs are the default.<br />
If AWS, GCP, and Cloudflare went dark, most apps would too.<br />
Sequencing is centralized by design in many rollups.<br />
Upgrade keys still exist. "Training wheels" are used as an excuse to
delay decentralization.<br />
"Self-custody" is delegated to CEXes.<br />
Cross-chain interoperability has begun to mirror the very centralization
it was meant to overcome — solvers and relayers act as gatekeepers of
execution, deciding which transactions succeed and which fail.</p>
<p>Trust does not return all at once.<br />
It returns through defaults slowly.<br />
Each choice feels harmless, temporary — not like centralization.</p>
<p>No capture, no coup — just comfort.<br />
Help becomes habit; habit becomes dependence.<br />
Soon participation depends on infrastructure that only a few can run,
and verification becomes the privilege of specialists.</p>
<p>This is how decentralization erodes — not in theory, but in
production.<br />
Not tomorrow, but <strong>today</strong>.</p>
<p>Decentralization erodes not through capture, but through
convenience.<br />
It drifts — automatically, continually — toward dependence on trust.</p>
<hr />
<h2 id="vi.-the-limits-of-delegation">VI. The limits of delegation</h2>
<p>Delegation may exist. Dependence must not.<br />
Users may choose convenience — a hosted node, a friendly UI, a service
that helps them — the protocol must never require it.</p>
<p>If inclusion requires an intermediary, it is not trustless.<br />
If that intermediary must be trusted, it is not neutral.<br />
If users can "theoretically" run their own intermediary but in practice
never will, the system has replaced permissionless access with
<em>technical gatekeeping.</em></p>
<p>A permissionless protocol must not only be <em>open in code</em>, but
<em>open in cost, accessibility, and comprehension.</em></p>
<p>We have seen this pattern before.<br />
Email was once fully open — anyone could run their own mailserver.<br />
In theory, you still can.<br />
But in practice, spam filters, blocklists, and reputation systems make
it nearly impossible for ordinary users.<br />
Email became effectively centralized — not because the protocol was
closed, but because <strong>practical trustlessness was
lost</strong>.</p>
<p>We must not let Ethereum's access layer follow the same path.</p>
<hr />
<h2 id="vii.-the-duty-of-builders">VII. The duty of builders</h2>
<p>We who design protocols are stewards, not gatekeepers.<br />
Our duty is not to build what is easiest, but what remains open and
self-sovereign.</p>
<p>When complexity tempts us to centralize, we must remember: every line
of convenience code can become a choke point.<br />
When critics ask why our designs are complicated, we should ask them
what — or <strong>whom</strong> — they are trusting instead.<br />
If simplicity comes from trust, it is not simplicity. It is
surrender.</p>
<p>Trustlessness costs computation, latency, and mental effort.<br />
It buys resilience, longevity, neutrality, and freedom.</p>
<p>Trustlessness also requires viable incentives.<br />
Systems must reward those who sustain them without turning them into
gatekeepers.<br />
A protocol that relies on unpaid altruism will decay.<br />
A protocol that rewards control will centralize.<br />
The only stable equilibrium is one where neutrality is profitable.</p>
<hr />
<h2 id="viii.-the-way-forward">VIII. The way forward</h2>
<p>Ethereum has scaled — now it must stay honest.</p>
<p>As we build new layers, new accounts, and new ways to interact, we
must preserve the properties that made Ethereum matter:</p>
<ul>
<li>Users initiate their own actions.<br />
</li>
<li>Anyone can verify and participate.<br />
</li>
<li>No one can be silently excluded.<br />
</li>
<li>Logic lives in code, not in contracts of trust.<br />
</li>
<li>Inclusion depends on incentives, not on reputation or
permission.</li>
</ul>
<p>Trustlessness is not perfection.<br />
It is a system that fails publicly, transparently, and recoverably —
rather than privately and silently.</p>
<hr />
<h2 id="ix.-the-pledge">IX. The pledge</h2>
<p>We choose to build trustless systems even when it is harder.<br />
We pay the cost of openness over the convenience of control.<br />
We do not outsource neutrality to anyone who can be bribed, coerced, or
shut down.<br />
We measure success not by transactions per second, but by <strong>trust
reduced per transaction</strong>.</p>
<p>We refuse to build on infrastructure we cannot replace.<br />
We refuse to call a system "permissionless" when only the privileged can
participate.<br />
We refuse to trade autonomy for polish, or freedom for frictionless
UX.<br />
Trustlessness is not preserved by consensus alone — it is preserved by
resistance.</p>
<p>If your protocol requires faith in an intermediary, change it.<br />
If it relies on a private gateway, replace it.<br />
If it hides critical state or logic offchain, expose it.</p>
<p>In the end, the world does not need more efficient middlemen.<br />
It needs fewer reasons to trust them.</p>
<hr />
<h3 id="trustlessness-is-the-foundation.">Trustlessness is the
foundation.</h3>
<p>Everything else is construction on top of it.<br />
The designs will change. The principles will not.</p>
 </div> 